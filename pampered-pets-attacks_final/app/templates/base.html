<!doctype html>
<html lang="en">
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)'], ['$', '$']],
      displayMath: [['\\[', '\\]']],
    },
    options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const btn = document.getElementById('formulaHelpBtn');
    if (!btn) return;

    const contentEl = document.getElementById('formulaHelpContent');

    const pop = new bootstrap.Popover(btn, {
      content: () => contentEl.innerHTML, // inject the hidden HTML
      html: true,
      sanitize: false,                    // allow MathJax HTML
      placement: 'auto',
      container: 'body',
      customClass: 'math-popover'
    });

    btn.addEventListener('shown.bs.popover', () => {
      const id = btn.getAttribute('aria-describedby');
      const popEl = document.getElementById(id);
      if (window.MathJax && popEl) {
        MathJax.typesetPromise([popEl]);  // typeset the LaTeX inside the popover
      }
    });
  });
</script>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Attack Tree Analyzer</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>

<body class="bg-body-light">
  <nav class="navbar navbar-expand-lg bg-body-tertiary shadow-sm">
    <div class="container">
      <a class="navbar-brand fw-semibold" href="{{ url_for('main.index') }}">
        Attack Tree Analyzer
      </a>
    </div>
  </nav>

  <main class="container my-4">
    {% with messages = get_flashed_messages() %}
    {% if messages %}
    {% for message in messages %}
    <div class="alert alert-warning alert-dismissible fade show" role="alert">
      {{ message }}
      <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>
    {% endfor %}
    {% endif %}
    {% endwith %}
    {% block content %}{% endblock %}
  </main>

  <footer class="border-top py-4 mt-5 small">
    <div class="container d-flex justify-content-between">
      <span class="text-muted">© 2025 — Attack Tree Analyzer</span>
      <span class="text-muted">Flask + Bootstrap 5</span>
    </div>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <style>
    .pz-viewport {
      height: 85vh;
      /* fills most of the screen */
      overflow: hidden;
      /* we pan inside this */
      position: relative;
      background: #111;
      cursor: grab;
    }

    .pz-viewport.panning {
      cursor: grabbing;
    }

    .pz-target {
      will-change: transform;
      user-select: none;
      -webkit-user-drag: none;
      transform-origin: 0 0;
      /* we manage the origin manually */
      /* Start “fit to width” */
      max-width: none;
      /* allow true scaling beyond natural size */
      max-height: none;
      display: block;
    }
  </style>
  <script>
    (() => {
      const modal = document.getElementById('treeZoomModal');
      const viewport = document.getElementById('pzViewport');
      const img = document.getElementById('pzTarget');
      const zoomInBtn = document.getElementById('zoomInBtn');
      const zoomOutBtn = document.getElementById('zoomOutBtn');
      const resetBtn = document.getElementById('resetBtn');

      // State
      let scale = 1, minScale = 0.5, maxScale = 6;
      let tx = 0, ty = 0; // translation
      let isPanning = false, startX = 0, startY = 0, startTx = 0, startTy = 0;

      function applyTransform() {
        img.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
      }

      // Fit image to viewport width on show
      modal.addEventListener('shown.bs.modal', () => {
        // natural size may not be loaded yet; ensure layout
        requestAnimationFrame(() => {
          const vw = viewport.clientWidth, vh = viewport.clientHeight;
          const naturalW = img.naturalWidth || img.width;
          const naturalH = img.naturalHeight || img.height;
          const fitScale = Math.min(vw / naturalW, vh / naturalH);
          scale = Math.max(Math.min(fitScale, 1), 0.2); // don't upscale too much on open
          // center
          const imgW = naturalW * scale, imgH = naturalH * scale;
          tx = (vw - imgW) / 2;
          ty = (vh - imgH) / 2;
          applyTransform();
        });
      });

      // Reset
      function resetView() {
        const vw = viewport.clientWidth, vh = viewport.clientHeight;
        const nw = img.naturalWidth || img.width;
        const nh = img.naturalHeight || img.height;
        const fitScale = Math.min(vw / nw, vh / nh);
        scale = Math.max(Math.min(fitScale, 1), 0.2);
        const imgW = nw * scale, imgH = nh * scale;
        tx = (vw - imgW) / 2;
        ty = (vh - imgH) / 2;
        applyTransform();
      }

      resetBtn.addEventListener('click', resetView);

      // Wheel / trackpad zoom (pinch is delivered as wheel with ctrlKey on many browsers)
      viewport.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = viewport.getBoundingClientRect();
        const cx = e.clientX - rect.left; // cursor in viewport coords
        const cy = e.clientY - rect.top;

        const zoomFactor = (e.deltaY < 0) ? 1.15 : 0.87; // smooth
        const newScale = Math.max(minScale, Math.min(maxScale, scale * zoomFactor));
        if (newScale === scale) return;

        // keep the point under cursor stable
        const sx = (cx - tx) / scale;
        const sy = (cy - ty) / scale;
        tx = cx - sx * newScale;
        ty = cy - sy * newScale;
        scale = newScale;
        applyTransform();
      }, { passive: false });

      // Buttons
      zoomInBtn.addEventListener('click', () => {
        const rect = viewport.getBoundingClientRect();
        const cx = rect.width / 2, cy = rect.height / 2;
        const newScale = Math.min(maxScale, scale * 1.2);
        const sx = (cx - tx) / scale, sy = (cy - ty) / scale;
        tx = cx - sx * newScale; ty = cy - sy * newScale; scale = newScale;
        applyTransform();
      });

      zoomOutBtn.addEventListener('click', () => {
        const rect = viewport.getBoundingClientRect();
        const cx = rect.width / 2, cy = rect.height / 2;
        const newScale = Math.max(minScale, scale / 1.2);
        const sx = (cx - tx) / scale, sy = (cy - ty) / scale;
        tx = cx - sx * newScale; ty = cy - sy * newScale; scale = newScale;
        applyTransform();
      });

      // Double click to zoom in / out
      viewport.addEventListener('dblclick', (e) => {
        const rect = viewport.getBoundingClientRect();
        const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
        const targetScale = (scale < 2) ? Math.min(3, scale * 2) : Math.max(1, scale / 2);
        const sx = (cx - tx) / scale, sy = (cy - ty) / scale;
        tx = cx - sx * targetScale; ty = cy - sy * targetScale; scale = targetScale;
        applyTransform();
      });

      // Pan with mouse drag
      viewport.addEventListener('mousedown', (e) => {
        isPanning = true;
        viewport.classList.add('panning');
        startX = e.clientX; startY = e.clientY;
        startTx = tx; startTy = ty;
      });
      window.addEventListener('mousemove', (e) => {
        if (!isPanning) return;
        tx = startTx + (e.clientX - startX);
        ty = startTy + (e.clientY - startY);
        applyTransform();
      });
      window.addEventListener('mouseup', () => {
        isPanning = false;
        viewport.classList.remove('panning');
      });

      // Touch: one-finger pan, two-finger pinch-zoom
      let lastTouchDist = null;
      viewport.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          isPanning = true;
          viewport.classList.add('panning');
          startX = e.touches[0].clientX; startY = e.touches[0].clientY;
          startTx = tx; startTy = ty;
        } else if (e.touches.length === 2) {
          isPanning = false;
          lastTouchDist = getTouchDist(e);
        }
      }, { passive: false });

      viewport.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (e.touches.length === 1 && isPanning) {
          tx = startTx + (e.touches[0].clientX - startX);
          ty = startTy + (e.touches[0].clientY - startY);
          applyTransform();
        } else if (e.touches.length === 2) {
          const rect = viewport.getBoundingClientRect();
          const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
          const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
          const dist = getTouchDist(e);
          if (lastTouchDist != null) {
            const factor = dist / lastTouchDist;
            const newScale = Math.max(minScale, Math.min(maxScale, scale * factor));
            const sx = (cx - tx) / scale, sy = (cy - ty) / scale;
            tx = cx - sx * newScale; ty = cy - sy * newScale; scale = newScale;
            applyTransform();
          }
          lastTouchDist = dist;
        }
      }, { passive: false });

      window.addEventListener('touchend', () => { lastTouchDist = null; isPanning = false; viewport.classList.remove('panning'); });

      function getTouchDist(e) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        return Math.hypot(dx, dy);
      }

      // Recenter when the modal is resized
      window.addEventListener('resize', () => {
        if (document.body.classList.contains('modal-open')) {
          // keep current scale, just keep image within viewport if tiny
          applyTransform();
        }
      });
    })();
  </script>

</body>

</html>